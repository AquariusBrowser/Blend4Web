<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: addons/hmd.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: addons/hmd.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

/**
 * Head Mounted Devices add-on.
 * Provides support for HMD devices using WebVR API.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API
 * @module hmd
 */

b4w.module["hmd"] = function(exports, require) {

var m_cam    = require("camera");
var m_cfg    = require("config")
var m_ctl    = require("controls");
var m_cont   = require("container");
var m_quat   = require("quat");
var m_print  = require("print");
var m_scenes = require("scenes");
var m_trans  = require("transform");
var m_util   = require("util");
var m_vec3   = require("vec3");
var m_vec4   = require("vec4");

var _hmd_data = null;

var _last_cam_quat = m_quat.create();
var _yaw_cam_angle = 0;

var _vec3_tmp  = m_vec3.create();
var _vec3_tmp2 = m_vec3.create();
var _vec3_tmp3 = m_vec3.create();
var _vec4_tmp  = m_vec4.create();
var _vec4_tmp2 = m_vec4.create();
var _quat_tmp  = m_quat.create();
var _quat_tmp2 = m_quat.create();
var _quat_tmp3 = m_quat.create();

var _hmd_params = {
    "oculus": {
        distortion_coefs : [0.22, 0.28],
        distortion_scale : 0.66,
        chromatic_aberration_coefs : [-0.015, 0.02, 0.025, 0.02]
    },
    "cardboard_1": {
        fov: 40,
        inter_lens_dist: 0.060,
        base_line_dist: 0.035,
        screen_to_lens_dist: 0.042,
        distortion_scale : 1.0,
        distortion_coefs: [0.441, 0.156],
        chromatic_aberration_coefs : [0.0, 0.0, 0.0, 0.0]
    },
    "cardboard_2": {
        fov: 60,
        inter_lens_dist: 0.064,
        base_line_dist: 0.035,
        screen_to_lens_dist: 0.039,
        distortion_scale : 1.0,
        distortion_coefs: [0.34, 0.55],
        chromatic_aberration_coefs : [0.0, 0.0, 0.0, 0.0]
    },
    "default": {
        distortion_coefs : [0.0, 0.0],
        distortion_scale : 1.0,
        chromatic_aberration_coefs : [0.0, 0.0, 0.0, 0.0]
    }
}

var _devices_params = {
    "Nexus6": {
        expr_user_agent: /Nexus 6 /,
        width_dist: 0.132,
        height_dist: 0.074,
        bevel_dist: 0.004
    },
    "GalaxyNote4": {
        expr_user_agent: /SM-N910C/,
        width_dist: 0.121,
        height_dist: 0.071,
        bevel_dist: 0.004
    },
    "YotaPhone2": {
        expr_user_agent: /YD201/,
        width_dist: 0.110,
        height_dist: 0.062,
        bevel_dist: 0.004
    },
    "default": {
        width_dist: 0.110,
        height_dist: 0.062,
        bevel_dist: 0.004
    }
}

/**
 * The WebVR API representation a head mounted display.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/HMDVRDevice
 * @typedef HMDVRDevice
 * @type {Object}
 */

/**
 * HMD behavior enum.
 * @see {@link module:hmd.HMD_NONE_MOUSE_ALL_AXES},
 * {@link module:hmd.HMD_ALL_AXES_MOUSE_NONE},
 * {@link module:hmd.HMD_ROLL_PITCH_MOUSE_YAW},
 * {@link module:hmd.HMD_ALL_AXES_MOUSE_YAW}
 * @typedef HMDBehavior
 * @type {Number}
 */

/**
 * HMD behavior: HMD does not affect camera orientation,
 * mouse controls camera rotation.
 * @const {HMDBehavior} module:hmd.HMD_NONE_MOUSE_ALL_AXES
 */
var HMD_NONE_MOUSE_ALL_AXES = 0;
exports.HMD_NONE_MOUSE_ALL_AXES = HMD_NONE_MOUSE_ALL_AXES;

/**
 * HMD behavior: HMD controls camera rotation,
 * mouse does not affect camera orientation.
 * @const {HMDBehavior} module:hmd.HMD_ALL_AXES_MOUSE_NONE
 */
var HMD_ALL_AXES_MOUSE_NONE = 1;
exports.HMD_ALL_AXES_MOUSE_NONE = HMD_ALL_AXES_MOUSE_NONE;

/**
 * HMD behavior: HMD controls roll and ritch rotation,
 * mouse controls yaw rotation.
 * @const {HMDBehavior} module:hmd.HMD_ROLL_PITCH_MOUSE_YAW
 */
var HMD_ROLL_PITCH_MOUSE_YAW = 2;
exports.HMD_ROLL_PITCH_MOUSE_YAW = HMD_ROLL_PITCH_MOUSE_YAW;

/**
 * HMD behavior: HMD affects camera rotation,
 * mouse affect yaw rotation.
 * @const {HMDBehavior} module:hmd.HMD_ALL_AXES_MOUSE_YAW
 */
var HMD_ALL_AXES_MOUSE_YAW = 3;
exports.HMD_ALL_AXES_MOUSE_YAW = HMD_ALL_AXES_MOUSE_YAW;

/**
 * Enable HMD.
 * @method module:hmd.enable_hmd
 * @param {HMDBehavior} control_type Camera rotation type.
 */
exports.enable_hmd = function(control_type) {
    // NOTE: navigator.getVRDevices return a promise
    if (navigator.getVRDevices) {
        navigator.getVRDevices().then(function(devices) {
            setup_devices(devices);
            process_hmd(control_type);
        });
    }
}

/**
 * Check if the browser supports WebVR API.
 * @method module:hmd.check_browser_support
 * @return {Boolean} Checking result.
 */
exports.check_browser_support = function() {
    return Boolean(navigator.getVRDevices);
}

function setup_devices(devices) {
    var webvr_hmd_devices = devices.filter(function(device) {
        return device instanceof HMDVRDevice;
    });

    var webvr_hmd_device = null;
    if (webvr_hmd_devices.length)
        // get first hmd device
        webvr_hmd_device = webvr_hmd_devices[0];

    var webvr_sensor_devices = null;
    if (webvr_hmd_device) {
        webvr_sensor_devices = devices.filter(function(device) {
            // NOTE: we tested only Oculus
            return device.deviceName.toLowerCase().indexOf("oculus") !== -1 &amp;&amp;
                    device.hardwareUnitId == webvr_hmd_device.hardwareUnitId &amp;&amp;
                    device instanceof PositionSensorVRDevice;
        });
    }

    // set up _hmd_data
    create_device_data(webvr_hmd_device, webvr_sensor_devices);
}

function init_device_data() {
    var hmd_data = {
        webvr_hmd_device           : null,
        webvr_sensor_devices       : null,

        // hmd properties
        viewer_name                : "",
        distortion_coefs           : new Float32Array(2),
        distortion_scale           : 1.0,
        chromatic_aberration_coefs : new Float32Array(4),
        fov_left                   : new Float32Array(4),
        fov_right                  : new Float32Array(4),
        inter_lens_dist            : 0.0,
        base_line_dist             : 0.0,
        screen_to_lens_dist        : 0.0,

        // mobile properties
        device_name                : "",
        width_dist                 : 0.0,
        height_dist                : 0.0,
        bevel_dist                 : 0.0,

        sensor                     : null
    };

    return hmd_data;
}

function create_device_data(webvr_hmd_device, webvr_sensor_devices) {
    if (!webvr_hmd_device &amp;&amp; !m_cfg.get("is_mobile_device")) {
        m_print.warn("Head-mounted display is not found.")
        return;
    }

    var hmd_data = _hmd_data = init_device_data();

    var viewer_name = "default";
    var device_name = "default";

    if (webvr_hmd_device) {
        hmd_data.webvr_hmd_device = webvr_hmd_device;
        hmd_data.webvr_sensor_devices = webvr_sensor_devices;
        if (webvr_hmd_device.deviceName.toLowerCase().indexOf("oculus") !== -1)
            viewer_name = "oculus";
    } else {
        for (var i in _devices_params) {
            if (navigator.userAgent.match(_devices_params[i].expr_user_agent)) {
                device_name = i;
                break;
            }
        }
        var device = _devices_params[device_name];
        hmd_data.width_dist = device.width_dist;
        hmd_data.height_dist = device.height_dist;
        hmd_data.bevel_dist = device.bevel_dist;

        // we tested only cardboard_2
        viewer_name = "cardboard_2";
    }

    if (viewer_name) {
        hmd_data.viewer_name = viewer_name;

        var viewer = _hmd_params[viewer_name];

        hmd_data.distortion_coefs[0] = viewer.distortion_coefs[0],
        hmd_data.distortion_coefs[1] = viewer.distortion_coefs[1];

        hmd_data.chromatic_aberration_coefs[0] = viewer.chromatic_aberration_coefs[0];
        hmd_data.chromatic_aberration_coefs[1] = viewer.chromatic_aberration_coefs[1];
        hmd_data.chromatic_aberration_coefs[2] = viewer.chromatic_aberration_coefs[2];
        hmd_data.chromatic_aberration_coefs[3] = viewer.chromatic_aberration_coefs[3];

        hmd_data.distortion_scale = viewer.distortion_scale;

        if (!hmd_data.webvr_hmd_device) {
            var device = _devices_params[device_name];
            update_fov(hmd_data, viewer, device);

            hmd_data.inter_lens_dist = viewer.inter_lens_dist;
            hmd_data.base_line_dist = viewer.base_line_dist;
            hmd_data.screen_to_lens_dist = viewer.screen_to_lens_dist;
        }
    }
}

function get_distort_fact_radius(distortion_coefs, radius) {
    var rsq = radius * radius;
    return radius * (1 + distortion_coefs[0] * rsq + distortion_coefs[1] * rsq * rsq);
}

function deg(x) {
    return x * 180 / Math.PI;
}

function update_fov(hmd_data, viewer, device) {
    var bottom_dist = viewer.base_line_dist - device.bevel_dist;
    var top_dist    = device.height_dist - bottom_dist;
    var inner_dist  = viewer.inter_lens_dist / 2;
    var outer_dist  = device.width_dist / 2 - viewer.inter_lens_dist;

    var distor_coef = hmd_data.distortion_coefs;

    var bottom_tang = get_distort_fact_radius(distor_coef,
            bottom_dist / viewer.screen_to_lens_dist);
    var bottom_angle = deg(Math.atan(bottom_tang));
    var top_tang = get_distort_fact_radius(distor_coef,
            top_dist / viewer.screen_to_lens_dist);
    var top_angle = deg(Math.atan(top_tang));
    var inner_tang = get_distort_fact_radius(distor_coef,
            top_dist / viewer.screen_to_lens_dist);
    var inner_angle = deg(Math.atan(inner_tang));
    var outer_tang = get_distort_fact_radius(distor_coef,
            top_dist / viewer.screen_to_lens_dist);
    var outer_angle = deg(Math.atan(outer_tang));

    hmd_data.fov_left[0] = Math.min(top_angle, viewer.fov);
    hmd_data.fov_left[1] = Math.min(inner_angle, viewer.fov);
    hmd_data.fov_left[2] = Math.min(bottom_angle, viewer.fov);
    hmd_data.fov_left[3] = Math.min(outer_angle, viewer.fov);

    hmd_data.fov_right[0] = Math.min(top_angle, viewer.fov);
    hmd_data.fov_right[1] = Math.min(outer_angle, viewer.fov);
    hmd_data.fov_right[2] = Math.min(bottom_angle, viewer.fov);
    hmd_data.fov_right[3] = Math.min(inner_angle, viewer.fov);
}

/**
 * Get mounted hmd device.
 * @method module:hmd.get_hmd_device
 * @return {HMDVRDevice} HMD object.
 */
exports.get_hmd_device = get_hmd_device;
function get_hmd_device() {
    return _hmd_data &amp;&amp; _hmd_data.webvr_hmd_device;
}

/**
 * Get mounted sensor devices.
 * @method module:hmd.get_sensor_devices
 * @return {HMDVRDevice} HMD object.
 */
exports.get_sensor_devices = get_sensor_devices;
function get_sensor_devices() {
    return _hmd_data &amp;&amp; _hmd_data.webvr_sensor_devices;
}

function get_sensor_orientation(dest) {
    var sensor_devices = get_sensor_devices();
    if (sensor_devices) {
        for (var i = 0; i &lt; sensor_devices.length; i++) {
            var sensor = sensor_devices[i];
            var state = sensor.getState();
            if (state.orientation) {
                if (!dest)
                    dest = m_quat.create();

                dest[0] = state.orientation["x"];
                dest[1] = state.orientation["y"];
                dest[2] = state.orientation["z"];
                dest[3] = state.orientation["w"];
            }
        }
    }
    return dest;
}

function get_sensor_angular_velocity(dest) {
    var sensor_devices = get_sensor_devices();
    if (sensor_devices) {
        for (var i = 0; i &lt; sensor_devices.length; i++) {
            var sensor = sensor_devices[i];
            var state = sensor.getState();
            if (state.angularVelocity) {
                if (!dest)
                    dest = m_quat.create();

                dest[0] = state.angularVelocity["x"];
                dest[1] = state.angularVelocity["y"];
                dest[2] = state.angularVelocity["z"];
                dest[3] = state.angularVelocity["w"];
            }
        }
    }
    return dest;
}

function get_sensor_position(dest) {
    var sensor_devices = get_sensor_devices();
    if (sensor_devices) {
        for (var i = 0; i &lt; sensor_devices.length; i++) {
            var sensor = sensor_devices[i];
            var state = sensor.getState();
            if (state.position) {
                if (!dest)
                    dest = m_vec3.create();

                dest[0] = state.position["x"];
                dest[1] = state.position["y"];
                dest[2] = state.position["z"];
            }
        }
    }
    return dest;
}

function get_eye_distance(eye) {
    var hmd_device = get_hmd_device();
    if (hmd_device) {
        var param_left = hmd_device.getEyeParameters("left");
        var param_right = hmd_device.getEyeParameters("right");
        return param_right.eyeTranslation["x"] - param_left.eyeTranslation["x"];
    } else if (_hmd_data) {
        return _hmd_data.inter_lens_dist;
    }
}

function get_fov(eye, dest) {
    var hmd_device = get_hmd_device();
    if (hmd_device) {
        var param = hmd_device.getEyeParameters(eye);

        if (param &amp;&amp; param.currentFieldOfView) {
            if (!dest)
                dest = m_vec4.create();

            dest[0] = param.currentFieldOfView["upDegrees"];
            dest[1] = param.currentFieldOfView["rightDegrees"];
            dest[2] = param.currentFieldOfView["downDegrees"];
            dest[3] = param.currentFieldOfView["leftDegrees"];
        }
    } else if (_hmd_data) {
        if (eye == "left")
            var fov = _hmd_data.fov_left;
        else
            var fov = _hmd_data.fov_right;

        if (!dest)
            dest = m_vec4.create();

        m_vec4.copy(fov, dest);
    }
    return dest;
}

/**
 * Reset the sensors, return position and orientation sensors values to zero.
 * @method module:hmd.reset
 */
exports.reset = reset_hmd;
function reset_hmd() {
    var sensor_devices = get_sensor_devices();
    if (sensor_devices) {
        for (var i = 0; i &lt; sensor_devices.length; i++) {
            var sensor = sensor_devices[i];
            sensor.resetSensor();
        }
    }
}

function process_hmd(control_type) {
    if (!_hmd_data)
        return;

    var elapsed = m_ctl.create_elapsed_sensor();
    if (get_hmd_device())
        var g_q_sensor = m_ctl.create_custom_sensor(1);
    else
        var g_q_sensor = m_ctl.create_gyro_quat_sensor();

    var updated_eye_data = false;
    var move_cam_cb = function(obj, id, pulse) {
        var cam_obj = m_scenes.get_active_camera();
        if (!cam_obj)
            return;

        if (pulse > 0) {
            // NOTE: init part
            if (!updated_eye_data) {
                var hmd_left_fov = get_fov("left", _vec4_tmp);
                var hmd_right_fov = get_fov("right", _vec4_tmp2);
                if (hmd_left_fov &amp;&amp; hmd_left_fov)
                    m_cam.set_hmd_fov(cam_obj, hmd_left_fov, hmd_right_fov);

                var eye_distance = get_eye_distance();
                if (eye_distance)
                    m_cam.set_eye_distance(cam_obj, eye_distance);

                var hmd_params = {};

                hmd_params.distortion_coefs = [
                        _hmd_data.distortion_coefs[0],
                        _hmd_data.distortion_coefs[1]
                ];

                hmd_params.chromatic_aberration_coefs = [
                        _hmd_data.chromatic_aberration_coefs[0],
                        _hmd_data.chromatic_aberration_coefs[1],
                        _hmd_data.chromatic_aberration_coefs[2],
                        _hmd_data.chromatic_aberration_coefs[3]
                ];

                hmd_params.distortion_scale  = _hmd_data.distortion_scale;
                // TODO: set distortion_offset
                hmd_params.distortion_offset = 0.0;
                hmd_params.enable_hmd_stereo = true;

                m_scenes.set_hmd_params(hmd_params);

                var canvas_container_elem = m_cont.get_container();
                var ccw = canvas_container_elem.clientWidth;
                var cch = canvas_container_elem.clientHeight;
                m_cont.resize(ccw, cch, true);

                updated_eye_data = true;

                _last_cam_quat = m_trans.get_rotation(cam_obj, _last_cam_quat);
                reset_hmd();
            }

            // NOTE: It is executed every frame.
            // uses _vec3_tmp, _vec3_tmp2, _vec3_tmp3, _quat_tmp, _quat_tmp2
            if (m_cam.is_eye_camera(cam_obj)) {
                var hmd_quat;
                if (!get_hmd_device())
                    hmd_quat = m_ctl.get_sensor_payload(obj, id, 1);
                else {
                    hmd_quat = get_sensor_orientation(_quat_tmp);
                    var quat = m_quat.setAxisAngle(m_util.AXIS_X, Math.PI / 2, _quat_tmp2);
                    hmd_quat = m_quat.multiply(hmd_quat, quat, _quat_tmp);
                }

                if (hmd_quat) {
                    if (control_type == HMD_ALL_AXES_MOUSE_NONE) {
                        var up_axis = m_vec3.transformQuat(m_util.AXIS_Z, hmd_quat, _vec3_tmp);
                        m_cam.set_vertical_axis(cam_obj, up_axis);
                        m_trans.set_rotation_v(cam_obj, hmd_quat);
                    } else if (control_type == HMD_ROLL_PITCH_MOUSE_YAW ||
                            control_type == HMD_ALL_AXES_MOUSE_YAW) {
                        var cam_quat = m_trans.get_rotation(cam_obj,
                                _quat_tmp2);
                        var inv_cam_quat = m_quat.invert(cam_quat,
                                _quat_tmp2);
                        var diff_cam_quat = m_quat.multiply(_last_cam_quat,
                                inv_cam_quat, _quat_tmp2);

                        var cur_vertical_axis = m_cam.get_vertical_axis(cam_obj,
                                _vec3_tmp);
                        if (Math.abs(cur_vertical_axis[2]) &lt; Math.PI / 4)
                            var first_horiz_vec = m_vec3.cross(cur_vertical_axis,
                                    m_util.AXIS_Z, _vec3_tmp2);
                        else if (Math.abs(cur_vertical_axis[1]) &lt; Math.PI / 4)
                            var first_horiz_vec = m_vec3.cross(cur_vertical_axis,
                                    m_util.AXIS_Y, _vec3_tmp2);

                        m_vec3.normalize(first_horiz_vec, first_horiz_vec);

                        var rotated_first_horiz_vec = m_vec3.transformQuat(
                                first_horiz_vec, diff_cam_quat, _vec3_tmp3);

                        var vertical_coef = m_vec3.dot(cur_vertical_axis,
                                rotated_first_horiz_vec);
                        var second_horiz_vec = m_vec3.scaleAndAdd(rotated_first_horiz_vec,
                                cur_vertical_axis, -vertical_coef, _vec3_tmp3);
                        m_vec3.normalize(second_horiz_vec, second_horiz_vec);

                        var sign_horiz_vec = m_vec3.cross(cur_vertical_axis,
                                first_horiz_vec, _vec3_tmp);
                        var abs_yaw_angle = Math.acos(m_util.clamp(
                                m_vec3.dot(first_horiz_vec, second_horiz_vec),
                                0, 1));
                        var sign_yaw_angle = m_util.sign(m_vec3.dot(
                                second_horiz_vec, sign_horiz_vec));
                        var diff_yaw_cam_angle = abs_yaw_angle * sign_yaw_angle;

                        _yaw_cam_angle += diff_yaw_cam_angle;
                        var yaw_cam_quat = m_quat.setAxisAngle(m_util.AXIS_Y,
                                -_yaw_cam_angle, _quat_tmp2);

                        if (control_type == HMD_ALL_AXES_MOUSE_YAW) {
                            var new_cam_quat = m_quat.multiply(yaw_cam_quat,
                                    hmd_quat, _quat_tmp);
                        } else {
                            var yaw_hmd_quat = m_util.quat_project(hmd_quat, m_util.AXIS_MY,
                                    m_util.AXIS_Y, m_util.AXIS_MZ, _quat_tmp3);
                            var yaw_hmd_inv_quat = m_quat.invert(yaw_hmd_quat, _quat_tmp3);
                            var vertical_hmd_quat = m_quat.multiply(
                                    yaw_hmd_inv_quat, hmd_quat, _quat_tmp3);

                            var new_cam_quat = m_quat.multiply(yaw_cam_quat,
                                    vertical_hmd_quat, _quat_tmp);
                        }
                        var up_axis = m_vec3.transformQuat(m_util.AXIS_Z,
                                new_cam_quat, _vec3_tmp);
                        m_cam.set_vertical_axis(cam_obj, up_axis);

                        m_trans.set_rotation_v(cam_obj, new_cam_quat);
                        m_quat.copy(new_cam_quat, _last_cam_quat);
                    }
                }
            }
        }
    }
    m_ctl.create_sensor_manifold(null, "HMD_ROTATE_CAMERA", m_ctl.CT_CONTINUOUS,
            [elapsed, g_q_sensor], null, move_cam_cb);
}

/**
 * Disable HMD.
 * @method module:hmd.disable_hmd
 */
exports.disable_hmd = function() {
    m_ctl.remove_sensor_manifold(null, "HMD_ROTATE_CAMERA");

    // set up non-vr mode
    var hmd_params = {};
    hmd_params.enable_hmd_stereo = false;
    m_scenes.set_hmd_params(hmd_params);

    // resize screen to canvas resolution (non-vr mode)
    var canvas_container_elem = m_cont.get_container();
    var ccw = canvas_container_elem.clientWidth;
    var cch = canvas_container_elem.clientHeight;
    m_cont.resize(ccw, cch, true);

    // correct up camera (non-vr mode)
    var cam_obj = m_scenes.get_active_camera();
    m_cam.set_vertical_axis(cam_obj, m_util.AXIS_Y);

    // TODO: update_transform
    var cam_quat = m_trans.get_rotation(cam_obj, _quat_tmp);
    m_trans.set_rotation_v(cam_obj, cam_quat);
}

};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-anchors.html">anchors</a></li><li><a href="module-animation.html">animation</a></li><li><a href="module-app.html">app</a></li><li><a href="module-armature.html">armature</a></li><li><a href="module-assets.html">assets</a></li><li><a href="module-camera.html">camera</a></li><li><a href="module-camera_anim.html">camera_anim</a></li><li><a href="module-config.html">config</a></li><li><a href="module-constraints.html">constraints</a></li><li><a href="module-container.html">container</a></li><li><a href="module-controls.html">controls</a></li><li><a href="module-data.html">data</a></li><li><a href="module-debug.html">debug</a></li><li><a href="module-geometry.html">geometry</a></li><li><a href="module-gyroscope.html">gyroscope</a></li><li><a href="module-hmd.html">hmd</a></li><li><a href="module-hud.html">hud</a></li><li><a href="module-lights.html">lights</a></li><li><a href="module-main.html">main</a></li><li><a href="module-mat3.html">mat3</a></li><li><a href="module-mat4.html">mat4</a></li><li><a href="module-material.html">material</a></li><li><a href="module-mixer.html">mixer</a></li><li><a href="module-mouse.html">mouse</a></li><li><a href="module-nla.html">nla</a></li><li><a href="module-npc_ai.html">npc_ai</a></li><li><a href="module-ns_compat.html">ns_compat</a></li><li><a href="module-objects.html">objects</a></li><li><a href="module-particles.html">particles</a></li><li><a href="module-physics.html">physics</a></li><li><a href="module-preloader.html">preloader</a></li><li><a href="module-quat.html">quat</a></li><li><a href="module-rgb.html">rgb</a></li><li><a href="module-rgba.html">rgba</a></li><li><a href="module-scenes.html">scenes</a></li><li><a href="module-screenshooter.html">screenshooter</a></li><li><a href="module-sfx.html">sfx</a></li><li><a href="module-storage.html">storage</a></li><li><a href="module-textures.html">textures</a></li><li><a href="module-time.html">time</a></li><li><a href="module-transform.html">transform</a></li><li><a href="module-tsr.html">tsr</a></li><li><a href="module-util.html">util</a></li><li><a href="module-vec3.html">vec3</a></li><li><a href="module-vec4.html">vec4</a></li><li><a href="module-version.html">version</a></li></ul><h3>Namespaces</h3><ul><li><a href="b4w.html">b4w</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Fri Feb 26 2016 15:16:12 GMT+0300 (MSK)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
